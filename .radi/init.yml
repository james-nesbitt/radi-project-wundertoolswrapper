- Type: File
  path: .radi/authorize.yml
  Contents: |2
    Rules:
    
      - Id: Default
        Operation: "*"
        Authorize: Allow
        
- Type: File
  path: .radi/commands.yml
  Contents: |2
    build:
      privileged: true
      description: Build the WT application
      image: quay.io/wunder/fuzzy-alpine-devshell
      hostname: "build"
      working_dir: /app
      environment:
        PROJECT: "%PROJECT%"
        PROJECTROOT: "/app/project"
        BUILDROOT: "/app/project/drupal/current"
        DOCKERREPO: "quay.io/"
      entrypoint:
        - /bin/sh
        - /app/build.sh
      volumes:
        - /var/run/docker.sock:/var/run/docker.sock
    
        - "./:/app/project"
        - ".radi/tools/wundertools/build.sh:/app/build.sh"
    
        - "~/.gitconfig:/app/.gitconfig:ro"
        - "~/.ssh:/app/.ssh:ro"
    
    # Give a ZSH tool shell with access to the project containers
    #
    # @NOTE Requires that you have the project containers built and running
    shell:
      description: Give a command shell, with access to the application
      image: quay.io/wunder/fuzzy-alpine-devshell
      hostname: "shell"
      working_dir: /app
      volumes_from:
        - source
        - assets
      volumes:
        - "!:/app/pwd"
        - "./:/app/project"
    
        - "~/.gitconfig:/app/.gitconfig:ro"
        - "~/.ssh:/app/.ssh:ro"
      links:
        - db:db.app
        - fpm:fpm.app
        - www:www.app
    
    # Drupal Console
    drupal:
      description: Run drupal console on the application
      image: quay.io/wunder/fuzzy-alpine-devshell
      working_dir: /app/web
      entrypoint:
        - /app/vendor/bin/drupal
        - --ansi
      volumes_from:
        - source
        - assets
      volumes:
        - "./backup:/app/backup"
        - "./settings/drush:/app/.drush"
        - "./settings/drupal-console:/app/.drupal"
        - "./source/drupal/conf/composer.json:/app/.composer.json"
        - "./source/drupal/conf/composer.lock:/app/.composer.lock"
    
        - "~/.gitconfig:/app/.gitconfig:ro"
        - "~/.ssh:/app/.ssh:ro"
      links:
        - db:db.app
        
- Type: File
  path: .radi/project.yml
  Contents: |2
    Components:
    
      # Base implmentation is a local project
      - Type: local
        Implementations:
          - config
          - setting
          - project
          - security
    
      # Also use the local API for commands and orchestration
      - Type: local
        Implementations:
          - orchestrate
          - command
        
- Type: File
  path: .radi/settings.yml
  Contents: |2
    Project: "%PROJECT%"
        
- Type: File
  path: .radi/tools/wundertools/Dockerfile
  Contents: |2
    # Wundertools Wrapper Docker build file
    #
    # This build expects:
    #   1. this docker build should be run after a composer install has been used to retrieve vendor/build www
    #   2. docker build using this file should be executed from the project source root (copy this file there first)
    #
    FROM quay.io/wunder/fuzzy-alpine-base:v3.4
    MAINTAINER james.nesbitt@wunder.io
    
    # Add core source
    ADD drupal/current/web /app/web
    ADD drupal/current/vendor /app/vendor
    
    # Now it appears that drupal console wants to see composer files.
    ADD drupal/conf/composer.json /app/composer.json
    ADD drupal/conf/composer.lock /app/composer.lock
    
    # Add project code and conf
    ADD drupal/code/modules/custom /app/web/modules/custom
    ADD drupal/code/themes/custom /app/web/themes/custom
    #ADD drupal/code/profiles/custom /app/web/profiles/custom
    #ADD drupal/code/libraries/custom /app/web/libraries/custom
    
    # Add in Drupal config
    ADD drupal/config/sync /app/config
    
    # Add Drupal site settings
    ADD drupal/conf/services.yml /app/web/sites/default/services.yml
    ADD drupal/conf/settings.php /app/web/sites/default/settings.php
    ADD drupal/conf/radi.settings.php /app/web/sites/default/settings.local.php
    ADD drupal/conf/radi.services.yml /app/web/sites/default/services.local.yml
        
- Type: File
  path: .radi/tools/wundertools/README.md
  Contents: |2
    WUNDERTOOLS
    -----------
    
    This folder hols tools that are used to integrate the wundertools projects
    into the radi implementation.
    
    Primarily, the tools exist to build a source code image from the WT project
    which can then be used by any docker/docker-compose implementation.
    
    
    > See the `build` command in the .radio/commands.yml
        
        
- Type: File
  path: .radi/tools/wundertools/build.sh
  Contents: |2
    #!/bin/sh
    ##########
    #
    # Build the project source code:
    #   - build a docker image with web source
    #
    # Usage:
    #   --no-composer : don't run the composer part of the build (just build the image)
    #   --composer-update : run composer update instead of just composer install
    #   --no-image-build : don't build the docker image (just run composer)
    #   --push-image : docker push the image
    #
    
    echo "----------------------------------------------
    Commencing WunderTools -> Radi build
    "
    
    ##### Interpret arguments #####################################################
    
    sflag="-s"
    for arg in "$@"
    do
    	case "$arg" in
    
    	--no-composer)
    		echo " -> DISABLING COMPOSER RUN"
    		RUN_COMPOSER="no"
    		;;
    
    	--composer-update)
    		echo " -> COMPOSER WILL UPDATE INSTEAD OF INSTALL"
    		COMPOSER_COMMAND="update"
    		;;
    
    	--no-image-build)
    		echo " -> DISABLING DOCKER IMAGE BUILD"
    		RUN_IMAGEBUILD="no"
    		;;
    
    	--push-image)
    		echo " -> PUSHING DOCKER IMAGE BUILD"
    		RUN_IMAGEPUSH="yes"
    		;;
    
    	esac
    done
    
    echo " "
    
    ##### Some configurations #####################################################
    
    PROJECT="${PROJECT:-wundertools}"
    
    DOCKERREPO="${DOCKERREPO:-quay.io/}"
    IMAGEROOT="${IMAGEROOT:-wunder/project-}"
    
    [ -z "${IMAGENAME}" ] && IMAGENAME="${DOCKERREPO}${IMAGEROOT}${PROJECT}-source"
    
    PROJECTROOT="/app/project"
    DRUPALROOT="${PROJECTROOT}/drupal"
    
    RUN_COMPOSER="${RUN_COMPOSER:-yes}"
    RUN_IMAGEBUILD="${RUN_IMAGEBUILD:-yes}"
    RUN_IMAGEPUSH="${RUN_IMAGEPUSH:-no}"
    
    COMPOSER_COMMAND="${COMPOSER_COMMAND:-install}"
    
    ##### BUILD PROJECT SOURCE ####################################################
    
    if [ "${RUN_COMPOSER}" = "yes" ]; then
    
    	# let's build to /app/project/drupal/current, just like wundertools does.
    	# Then PHPStorm can easily be made to keep working.
    
    	echo "----- Using composer to generate full project source -----"
    
    	BUILDROOT="${DRUPALROOT}/current"
    
    	echo "--> configured
    	PROJECTROOT-------:${PROJECTROOT}
    	DRUPALROOT--------:${DRUPALROOT}
    	BUILDROOT---------:${BUILDROOT}
    	"
    
    	echo "--> Creating source build destination ${BUILDROOT}"
    	sudo rm -rf "${BUILDROOT}"
    	mkdir -p "${BUILDROOT}"
    
    	# Get ready for the composer build
    	cp "${DRUPALROOT}/conf/composer.json" "${BUILDROOT}/composer.json"
    	cp "${DRUPALROOT}/conf/composer.lock" "${BUILDROOT}/composer.lock"
    
    
    	# BUild main Drupal
    	echo "--> using composer to build full project source"
    	(/usr/local/bin/composer --working-dir="${BUILDROOT}" --optimize-autoloader "${COMPOSER_COMMAND}")
    
    	# Add in custom files
    
    	####
    	# It is better just to configure PHPstorm to know that the module code is in DRUPALROOT
    	# instead of putting that code into current.  The code will be mapped into the right
    	# place during docker build, and so isn't needed in current.
    	####
    
    	# Add project code and conf
    	# echo "--> Adding in custom modules/themes"
    	mkdir -p "${BUILDROOT}/web/modules/custom"
    	# cp -R "${DRUPALROOT}/code/modules/custom" "${BUILDROOT}/web/modules/custom"
    	mkdir -p "${BUILDROOT}/web/themes/custom"
    	# cp -R "${DRUPALROOT}/code/themes/custom" "${BUILDROOT}/web/themes/custom"
    	mkdir -p "${BUILDROOT}/web/profiles/custom"
    	#ADD drupal/code/profiles/custom /app/web/profiles/custom
    	mkdir -p "${BUILDROOT}/web/libraries/custom"
    	#ADD drupal/code/libraries/custom /app/web/libraries/custom
    
    	# Prepare for files (creating the folder now fixes file permissions when bound)
    	mkdir -p "${BUILDROOT}/web/sites/default/files"
    
    	# Drupal site settings [this overwrites files in the current, so it may be a bit better]
    	echo "--> copying over Drupal settings into default site"
    	#mkdir -p "${BUILDROOT}/web/sites/default"
    	cp -R "${DRUPALROOT}/conf/services.yml" "${BUILDROOT}/web/sites/default/services.yml"
    	cp -R "${DRUPALROOT}/conf/settings.php" "${BUILDROOT}/web/sites/default/settings.php"
    	cp -R "${DRUPALROOT}/conf/radi.services.yml" "${BUILDROOT}/web/sites/default/services.local.yml"
    	cp -R "${DRUPALROOT}/conf/radi.settings.php" "${BUILDROOT}/web/sites/default/settings.local.php"
    	# rm "${BUILDROOT}/web/sites/default/default.*"
    	# rm "${BUILDROOT}/web/sites/example.*"
    
    fi
    
    ##### BUILD SOURCE CODE IMAGE #################################################
    
    if [ "${RUN_IMAGEBUILD}" = "yes" ];then
    
    	echo "----- Building Docker image -----"
    
    	# Put the Dockerfile in place
    	echo "--> Temporarily copying Dockerfile to project root: ${PROJECTROOT}/.radi/tools/wundertools/Dockerfile => ${PROJECTROOT}/Dockerfile"
    	cp "${PROJECTROOT}/.radi/tools/wundertools/Dockerfile" "${PROJECTROOT}/Dockerfile"
    
    	# run the docker build
    	echo "--> building docker image for source code [production safe]"
    	(sudo docker build --tag "${IMAGENAME}" "${PROJECTROOT}")
    	echo "--> image build: ${IMAGENAME}"
    
    	# remove the temp Dockerfile position
    	rm "${PROJECTROOT}/Dockerfile"
    
    fi
    
    ##### PUSH IMAGE TO DOCKER REPOSITORY #########################################
    
    
    if [ "${RUN_IMAGEPUSH}" = "yes" ];then
    
    	echo "----- Pushing Docker image -----"
    
    	echo ">> Logging into docker repository: ${DOCKERREPO}"
    	sudo docker login "${DOCKERREPO}"
    
    	# run the docker build
    	(sudo docker push "${IMAGENAME}")
    	echo "--> image pushed: ${IMAGENAME}"
    
    fi
    
    echo ">> Build is finished"
        
- Type: File
  path: .radi/tools/wundertools/radify.sh
  Contents: |2
    #!/bin/bash
    #
    # WUNDERTOOLS : RADIFY
    #
    # This is a shell script that is meant to be used to convert an existing 
    # Wundertools D8 project into a radi compatible project.
    #
    # The process is meant to be non-destructive, and introduct minimal 
    # changes to the project source code.
    #
    # This script should be run in the root of a wundertools project.
    #
    
    INIT_PATHS="https://raw.githubusercontent.com/wunderkraut/radi-project-wundertoolswrapper/master/.radi/init.yml"
    
    echo "##### RADIFY YOUR WUNDERTOOLS #####
    
    You are about to run a script that will add radi configuration and aids into 
    your existing project.
    
    This process is meant to radify an existing WUNDERTOOLS D8 project, with no 
    modifications to the actual project.  This script is however not very 
    sophisticated, so there is a chance that it will overwrite an existing file.
    
    #### How it works:
    
    The process is primarily template driven.
    
    The answers to the questions asked may modify which templates are used, but 
    they are primarily used to provide string substitutions for the templates,
    and to allow you to control what actions the script will take.
    
    This script should have been run/downloaded as: 
      https://github.com/wunderkraut/radi-project-wundertoolswrapper/blob/master/.radi/tools/wundertools/radify.sh
    or the gist:
      https://gist.github.com/james-nesbitt/7ebf7337cbfa3f2eef69a59f05fbfc50
    
    #### Running radification
    
    We will now start the script
    
    Shall we proceed? (y/N)
    "
    read YNPROCEED
    case "$YNPROCEED" in
        [Yy]* )
    
    		echo " "
    		echo "Proceeding --->"
    		echo " "
    
    		;;
        *)
    		echo " "
    		echo "Aborting "
    		echo " "
    		exit 1	
    esac
    
    ### Some utility functions
    
    
    
    ### STARTING radification
    
    echo "##### Initial questions 
    
    Now we will ask a few questions to preconfigure the process
    
    "
    
    if [ -z "${PROJECT}" ]; then
    	echo "What is a good machine name for your project?
    
    	   This should be a lowercase string (no spaces numbers or symbols)
    
    	   This will be used as a template substitution variable, which will populate
    	   files used to configure radi for the project.  The result will also impact
    	   the docker-compose file, which will mean that all networks, volumes and 
    	   containers may contain this string as a root key value.
    	   "
    	read PROJECT 
    
    	echo " "
    fi
    
    echo "##### Processing init templates
    
    In this stage we will use one or more radi initialization templates to add files 
    to your project.
    We will download each template to a temporary file on your host, process it, and
    then run it.
    
    The current templates being 
    considered are: 
    ${INIT_PATHS}
    
    "
    
    for INITURL in $INIT_PATHS; do
    
    	TMPFILE="`mktemp`"
    
    	echo "INIT> ${INITURL} [temporarily in : ${TMPFILE}"
    
    	curl -s -o "${TMPFILE}" "${INITURL}"
    
    	echo "  --> replacing Project template variable"
    	sed -i -e "s/\%PROJECT\%/${PROJECT}/g" "${TMPFILE}"
    
    	echo "  --> Running template init:"
    	radi local.project.create --project.create.source "${TMPFILE}"
    
    	rm "${TMPFILE}"
    
    done
    
    echo " 
    
    Intialization complete
    
    
    ##### Finalization
    
    Now that the project initialization is complete, you should be able to run radi'
    as a command line tool anywhere inside your project.
    
    The first steps that you should perform, in order to be able to start using the
    the tool, are to perform the source code image build.
    You can do this at anytime using the build command (see .radi/commands.yml)
    
    $/> radi build
    
    The build creates a docker image with source code in it, that can be used in
    production, but can also be used locally with local source code bound in place.
    
    "
    
    echo "Would you like me to run the initial image build (probably 2 minutes build time)? (y/N)"
    read YNBUILD
    case "$YNBUILD" in
        [Yy]* )
    
    		echo " "
    		echo "Running build --->"
    		echo " "
    
    		(radi build)
    
    		;;
    esac
        
- Type: File
  path: README.md
  Contents: |2
    # radi WT wrapper
    
    This is a radi init template that can be used to make an existing wundertools
    project work with radi.
    
    Using the template, you can add the needed files to any wundertools project,
    and run a few commands to add the needed docker/radi infrastructure to use
    radi right away.
    
    ## What is added
    
    ### a number of files used to configure radi
    
    1. some base radi settings in .radi
    2. a radi command `build` which is used as a replacement for the build.sh that
       wundertools provides, which builds a full source code docker image for the
       project.  This image could be used in production.
    
    ### some files usable by docker-compose
    
    . docker-compose.yml which uses the source code image for local development.
    
    ### A radi build command
    
    you can run `radi build` which will build a new source code image for the project.
    
    ## How to use it:
    
    ### 1. Install radi-cli (https://github.com/wunderkraut/radi-cli)
    
    ### 2. In any wundertools D8 project root, use the init.yml from this repository
    
    run:
    
    ```
    $/> radi local.project.create --project.create.source https://raw.githubusercontent.com/wunderkraut/radi-project-wundertoolswrapper/master/.radi/init.yml
    ```
    
    This should add the needed files.
    
    ### 3. Change some settings
    
    The only setting that needs assignment can be done by string replacing %PROJECT% 
    across all of the added files with a string name for the project.
    
    This will likey be automated next, but there are only a few instances, so it is usable
    already.
        
- Type: File
  path: docker-compose.yml
  Contents: |2
    
    version: "2"
    
    services:
    
      source:
        image: "quay.io/wunder/client-%PROJECT%-source"
        command:
          - /bin/true
        volumes:
          # Allow local volume binding overrides
          - "./drupal/current/web:/app/web"
          - "./drupal/current/vendor:/app/vendor"
          - "./drupal/config/sync:/app/config"
          - "./drupal/code/modules/custom:/app/web/modules/custom"
          - "./drupal/code/themes/custom:/app/web/themes/custom"
          - "./drupal/code/profiles/custom:/app/web/profiles/custom"
          # - "./drupal/code/libraries/custom:/app/web/libraries/custom"
    
      assets:
        image: quay.io/wunder/fuzzy-alpine-base
        command:
          - /bin/true
        volumes:
          # Keep assets outside of the image, you could map these to
          # local paths if you want to keep assets locally.
          - "/app/web/sites/default/files"
          - "/app/private"
    
      ####
      # Servers
      #
    
      ####
      # DB node
      #
      db:
        image: quay.io/wunder/fuzzy-alpine-mariadb
    
      ####
      # MemCacheD
      #
      memcache:
        image: quay.io/wunder/fuzzy-alpine-memcached
    
      ####
      # FPM node
      #
      # @NOTE in production, the source volumes should be source:ro
      #  but local devs may need to write to settings.php
    
      fpm:
        image: quay.io/wunder/fuzzy-alpine-php-dev
        volumes_from:
          - source
          - assets
        environment:
          DNSDOCK_ALIAS: fpm.%PROJECT%.docker
        links:
          - db:db.app
          - memcache:memcached.app
    
      ####
      # WWW node
      #
      www:
        image: quay.io/wunder/fuzzy-alpine-nginx-pagespeed-drupal
        ports:
          - 8081:80
        volumes_from:
          - source
          - assets
        environment:
          DNSDOCK_ALIAS: www.%PROJECT%.docker
        links:
          - fpm:fpm.app
    
      ####
      # Static cache service
      #
      varnish:
        image: quay.io/wunder/fuzzy-alpine-varnish
        ports:
          - 8080:80
        environment:
          DNSDOCK_ALIAS: %PROJECT%.docker
          VARNISH_BACKEND_HOST: backend.app
        links:
          - www:backend.app
        
- Type: File
  path: drupal/conf/radi.settings.php
  Contents: |2
    <?php
    
    /**
     * INSTALLATION SETTINGS
     *
     * You will want to comment these out if you need to install again
     */
    
    $databases = array (
      'default' => 
      array (
        'default' => 
        array (
          'database' => 'app',
          'username' => 'app',
          'password' => 'app',
          'host'     => 'db.app',
          'port'     => '',
          'driver'   => 'mysqli',
          'prefix'   => '',
        ),
      ),
    );
    
    // We assume that you performed a standard or config-import install
    $settings['install_profile'] = 'standard';
    
    // We assume that the sync folder is mounted at /app/config
    $config_directories['sync'] = '/app/config';
    
    /**
     * General settings for developers
     */
    
    // Use this to get rid of those warnings
    // $settings['trusted_host_patterns'] = array(
    //   '\.docker$',
    // );
    
    $settings['file_temporary_path'] = '/tmp';
    
    /**
     * Assertions.
     *
     * The Drupal project primarily uses runtime assertions to enforce the
     * expectations of the API by failing when incorrect calls are made by code
     * under development.
     *
     * @see http://php.net/assert
     * @see https://www.drupal.org/node/2492225
     *
     * If you are using PHP 7.0 it is strongly recommended that you set
     * zend.assertions=1 in the PHP.ini file (It cannot be changed from .htaccess
     * or runtime) on development machines and to 0 in production.
     *
     * @see https://wiki.php.net/rfc/expectations
     */
    assert_options(ASSERT_ACTIVE, TRUE);
    \Drupal\Component\Assertion\Handle::register();
    
    /**
     * Enable local development services.
     */
    if (file_exists(__DIR__.'/local.services.yml')) {
      $settings['container_yamls'][] = __DIR__.'/local.services.yml';
    }
    
    /**
     * Show all error messages, with backtrace information.
     *
     * In case the error level could not be fetched from the database, as for
     * example the database connection failed, we rely only on this value.
     */
    $config['system.logging']['error_level'] = 'verbose';
    
    /**
     * Disable CSS and JS aggregation.
     */
    $config['system.performance']['css']['preprocess'] = FALSE;
    $config['system.performance']['js']['preprocess'] = FALSE;
    
    /**
     * Disable some caching if needed.
     */
    //$settings['cache']['bins']['default'] = 'cache.backend.null';
    //$settings['cache']['bins']['render'] = 'cache.backend.null';
    //$settings['cache']['bins']['dynamic_page_cache'] = 'cache.backend.null';
    
    /**
     * Allow test modules and themes to be installed.
     */
    $settings['extension_discovery_scan_tests'] = TRUE;
    
    /**
     * Enable access to rebuild.php.
     */
    $settings['rebuild_access'] = TRUE;
    
    /**
     * Skip file system permissions hardening.
     */
    $settings['skip_permissions_hardening'] = TRUE;
        
- Type: File
  path: drupal/conf/radi.services.yml
  Contents: |2
    # Local development services.
    #
    # @NOTE these are copied from development.services.yml
    #
    # To activate this feature, follow the instructions at the top of the
    # 'example.settings.local.php' file, which sits next to this file.
    services:
      cache.backend.null:
        class: Drupal\Core\Cache\NullBackendFactory
        
